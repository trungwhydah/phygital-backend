// TODO: This file SHOULD be generated by iterating through `digital_asset_collections` collection in DB
package contracts

import (
	"errors"
	"log"
	"strings"

	"backend-service/internal/core_backend/common/logger"
	"backend-service/internal/core_backend/contracts/astronaut_nft"
	"backend-service/internal/core_backend/contracts/danonnuoc_nft"
	"backend-service/internal/core_backend/contracts/lej_nft"
	"backend-service/internal/core_backend/entity"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

var (
	logTransferSig                 = []byte("Transfer(address,address,uint256)")
	logOwnershipTransferredSig     = []byte("OwnershipTransferred(address,address)")
	LogTransferSigHash             = crypto.Keccak256Hash(logTransferSig)
	LogOwnershipTransferredSigHash = crypto.Keccak256Hash(logOwnershipTransferredSig)
)

func GetNFTInstance(contractAdd *string, client *ethclient.Client) interface{} {
	address := common.HexToAddress(*contractAdd)
	switch *contractAdd {
	case "0xb53351913607390576c3e8161405d9b16bae77f0":
		instance, err := lej_nft.NewLejNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		return instance
	case "0x4f3b348167bded078d6be6bcfdad473cccda8e86":
		instance, err := danonnuoc_nft.NewDanonnuocNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		return instance
	case "0xadbaeff0e947a8917104b76e700bc2111baeb70f":
		instance, err := astronaut_nft.NewAstronautNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		return instance
	default:
		return nil
	}
}

func SafeMint(contractAdd *string, client *ethclient.Client, auth *bind.TransactOpts, ownerAdd *common.Address) (*types.Transaction, error) {
	address := common.HexToAddress(*contractAdd)
	var tx *types.Transaction
	switch *contractAdd {
	case "0xb53351913607390576c3e8161405d9b16bae77f0":
		instance, err := lej_nft.NewLejNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		tx, err = instance.SafeMint(auth, *ownerAdd)
	case "0x4f3b348167bded078d6be6bcfdad473cccda8e86":
		instance, err := danonnuoc_nft.NewDanonnuocNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		tx, err = instance.SafeMint(auth, *ownerAdd)
	case "0xadbaeff0e947a8917104b76e700bc2111baeb70f":
		instance, err := astronaut_nft.NewAstronautNft(address, client)
		if err != nil {
			logger.LogError(err.Error())
		}
		tx, err = instance.SafeMint(auth, *ownerAdd)
	default:
		logger.LogError("Unknown contract address!: " + *contractAdd)
	}
	return tx, nil
}

func ParseTransfer(contractAdd *string, client *ethclient.Client, vLog types.Log) (*entity.EventTransfer, error) {
	switch *contractAdd {
	case "0xb53351913607390576c3e8161405d9b16bae77f0":
		contractAbi, err := abi.JSON(strings.NewReader(string(lej_nft.LejNftABI)))
		if err != nil {
			log.Fatal(err)
		}
		switch vLog.Topics[0].Hex() {
		case LogTransferSigHash.Hex():
			var transferEvent entity.EventTransfer
			err = contractAbi.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
			if err != nil {
				logger.LogError(err.Error())
			}
			transferEvent.FromAddr = common.HexToAddress(vLog.Topics[1].Hex())
			transferEvent.ToAddr = common.HexToAddress(vLog.Topics[2].Hex())
			transferEvent.TokenID = vLog.Topics[3].Big()
			return &transferEvent, err
		case LogOwnershipTransferredSigHash.Hex():
			logger.LogInfo("Ownership Of Contract Transferred Event Caught! (including creating contract)")
			return nil, nil
		default:
			err := errors.New("Unknown event type! Topic[0]: " + vLog.Topics[0].Hex())
			logger.LogError(err.Error())
			return nil, err
		}
	case "0x4f3b348167bded078d6be6bcfdad473cccda8e86":
		contractAbi, err := abi.JSON(strings.NewReader(string(danonnuoc_nft.DanonnuocNftABI)))
		if err != nil {
			log.Fatal(err)
		}
		switch vLog.Topics[0].Hex() {
		case LogTransferSigHash.Hex():
			var transferEvent entity.EventTransfer
			err = contractAbi.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
			if err != nil {
				logger.LogError(err.Error())
			}
			transferEvent.FromAddr = common.HexToAddress(vLog.Topics[1].Hex())
			transferEvent.ToAddr = common.HexToAddress(vLog.Topics[2].Hex())
			transferEvent.TokenID = vLog.Topics[3].Big()
			return &transferEvent, err
		case LogOwnershipTransferredSigHash.Hex():
			logger.LogInfo("Ownership Of Contract Transferred Event Caught! (including creating contract)")
			return nil, nil
		default:
			err := errors.New("Unknown event type! Topic[0]: " + vLog.Topics[0].Hex())
			logger.LogError(err.Error())
			return nil, err
		}
	case "0xadbaeff0e947a8917104b76e700bc2111baeb70f":
		contractAbi, err := abi.JSON(strings.NewReader(string(astronaut_nft.AstronautNftABI)))
		if err != nil {
			log.Fatal(err)
		}
		switch vLog.Topics[0].Hex() {
		case LogTransferSigHash.Hex():
			var transferEvent entity.EventTransfer
			err = contractAbi.UnpackIntoInterface(&transferEvent, "Transfer", vLog.Data)
			if err != nil {
				logger.LogError(err.Error())
			}
			transferEvent.FromAddr = common.HexToAddress(vLog.Topics[1].Hex())
			transferEvent.ToAddr = common.HexToAddress(vLog.Topics[2].Hex())
			transferEvent.TokenID = vLog.Topics[3].Big()
			return &transferEvent, err
		case LogOwnershipTransferredSigHash.Hex():
			logger.LogInfo("Ownership Of Contract Transferred Event Caught! (including creating contract)")
			return nil, nil
		default:
			err := errors.New("Unknown event type! Topic[0]: " + vLog.Topics[0].Hex())
			logger.LogError(err.Error())
			return nil, err
		}
	default:
		err := errors.New("Unknown contract address!: " + *contractAdd)
		logger.LogError(err.Error())
		return nil, err
	}
}
